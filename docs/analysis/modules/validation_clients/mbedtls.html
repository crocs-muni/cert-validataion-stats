<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>cevast.analysis.modules.validation_clients.mbedtls API documentation</title>
<meta name="description" content="This module contains an implementation of a certificate chain validation client for command-line MbedTLS â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cevast.analysis.modules.validation_clients.mbedtls</code></h1>
</header>
<section id="section-intro">
<p>This module contains an implementation of a certificate chain validation client for command-line MbedTLS.</p>
<p>The validation client can be both imported and used externally (as a standalone module) through the provided
command-line interface.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The validation client must be set up correctly before use. It is necessary to ensure, that MbedTLS is installed
correctly, "libfaketime.so.1" binary (used for setting reference time) is present, and that <code>TRUST_STORE_FILE</code> is
set to the path to the local trust store.</p>
<p>When using the validation client externally, these prerequisites are always checked before validation is performed.
When the validation client is imported, it is necessary to do these checks manually (i.e., using the method <code>is_setup_correctly()</code>).</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python3

&#34;&#34;&#34;
This module contains an implementation of a certificate chain validation client for command-line MbedTLS.

The validation client can be both imported and used externally (as a standalone module) through the provided
command-line interface.

..Important::
  The validation client must be set up correctly before use. It is necessary to ensure, that MbedTLS is installed
  correctly, &#34;libfaketime.so.1&#34; binary (used for setting reference time) is present, and that `TRUST_STORE_FILE` is
  set to the path to the local trust store.

  When using the validation client externally, these prerequisites are always checked before validation is performed.
  When the validation client is imported, it is necessary to do these checks manually (i.e., using the method `is_setup_correctly()`).
&#34;&#34;&#34;

import argparse
import datetime
import os
import subprocess
import tempfile


# noinspection PyBroadException
class MbedTLS:
    &#34;&#34;&#34;
    A class for certificate chain validation client utilizing command-line MbedTLS.

    Special error messages:

    &#34;Error&#34;: any error / exception not related to the certificate chain validation (algorithm) itself

    &#34;Unknown&#34;: validation result is unknown
    &#34;&#34;&#34;

    TRUST_STORE_FILE = &#34;/etc/pki/tls/cert.pem&#34;

    @staticmethod
    def verify(chain, reference_time=None, crl=None, **kwargs):
        &#34;&#34;&#34;
        Validates a certificate chain.

        `chain` is a list of paths to certificates forming a chain.
        `reference_time` is a reference time of validation in seconds since the epoch.
        `crl` is a path to CRL.
        `kwargs` are other, unexpected arguments.

        The returned result is a list of a set of error messages returned by command-line MbedTLS.
        &#34;&#34;&#34;

        chain = list(chain)

        try:
            with tempfile.NamedTemporaryFile() as chain_file:
                for i in range(len(chain)):
                    with open(chain[i]) as input_file:
                        chain[i] = input_file.read()

                    chain_file.write(chain[i].encode())

                chain_file.flush()

                command = []

                if reference_time:
                    command += MbedTLS.__get_faketime_command(reference_time)

                command += [&#34;mbedtls_cert_app&#34;, &#34;mode=file&#34;, &#34;filename={0}&#34;.format(chain_file.name), &#34;ca_file={0}&#34;.format(MbedTLS.TRUST_STORE_FILE)]

                if crl:
                    command += [&#34;crl_file={0}&#34;.format(crl)]

                command_output_lines = [line.strip() for line in subprocess.check_output([&#34; &#34;.join(command)], shell=True).decode(errors=&#34;ignore&#34;).strip().split(&#34;\n&#34;)]

                result = [&#34;Unknown&#34;]

                if command_output_lines[-1] == &#34;ok&#34;:
                    result = [&#34;Verified&#34;]
                elif command_output_lines[-1][0] == &#34;!&#34;:
                    messages = []

                    for i, line in enumerate(command_output_lines):
                        if line == &#34;failed&#34;:
                            for message_line in command_output_lines[i + 1:]:
                                if message_line[0] == &#34;!&#34;:
                                    messages.append(&#34;&#34;.join([word.capitalize() for word in message_line[1:].split()]))

                            break

                    if len(messages) &gt; 0:
                        result = sorted(set(messages))
        except Exception:
            result = [&#34;Error&#34;]

        return result

    @staticmethod
    def is_setup_correctly():
        &#34;&#34;&#34;
        Verifies that the validation client is set up correctly. (MbedTLS is installed, reference time works,
        and trust store exists)
        &#34;&#34;&#34;

        is_setup_correctly = True

        try:
            subprocess.check_output(&#34; &#34;.join([&#34;type&#34;, &#34;mbedtls_cert_app&#34;]), stderr=subprocess.DEVNULL, shell=True)
        except Exception:
            is_setup_correctly = False

        if is_setup_correctly:
            try:
                command_output = subprocess.check_output(&#34; &#34;.join(MbedTLS.__get_faketime_command(0) + [&#34;date&#34;, &#34;-u&#34;]), stderr=subprocess.DEVNULL, shell=True)

                if command_output.decode().strip() != &#34;Thu  1 Jan 01:00:00 CET 1970&#34;:
                    is_setup_correctly = False
            except Exception:
                is_setup_correctly = False

        if is_setup_correctly:
            if not os.path.isfile(MbedTLS.TRUST_STORE_FILE):
                is_setup_correctly = False

        return is_setup_correctly

    @staticmethod
    def __get_faketime_command(reference_time):
        return [&#34;LD_PRELOAD={0}&#34;.format(os.path.join(os.path.dirname(os.path.realpath(__file__)), &#34;libfaketime.so.1&#34;)),
                &#34;FAKETIME=\&#34;{0}\&#34;&#34;.format(datetime.datetime.fromtimestamp(reference_time).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;))]


if __name__ == &#34;__main__&#34;:
    argument_parser = argparse.ArgumentParser(description=&#34;chain format: ENDPOINT [INTERMEDIATE ...] [CA]&#34;)

    argument_parser.add_argument(&#34;-r&#34;, type=lambda s: int(datetime.datetime.strptime(s, &#34;%Y-%m-%d&#34;).timestamp()),
                                 required=False, dest=&#34;reference_date_as_time&#34;, metavar=&#34;DATE&#34;,
                                 help=&#34;reference date in format YYYY-MM-DD (at 00:00:00)&#34;)
    argument_parser.add_argument(&#34;-t&#34;, type=int, required=False, dest=&#34;reference_time&#34;, metavar=&#34;N&#34;,
                                 help=&#34;reference time in seconds since the epoch (surpassing reference date)&#34;)
    argument_parser.add_argument(&#34;--crl&#34;, type=str, required=False, dest=&#34;crl&#34;, metavar=&#34;FILE&#34;,
                                 help=&#34;certificate revocation list&#34;)
    argument_parser.add_argument(&#34;CERTIFICATE&#34;, type=str, nargs=&#34;+&#34;)

    if MbedTLS.is_setup_correctly():
        args = argument_parser.parse_args()
        print(MbedTLS.verify(args.CERTIFICATE, reference_time=args.reference_time if args.reference_time is not None else args.reference_date_as_time, crl=args.crl))
    else:
        print(&#34;Client is not set up correctly&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS"><code class="flex name class">
<span>class <span class="ident">MbedTLS</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class for certificate chain validation client utilizing command-line MbedTLS.</p>
<p>Special error messages:</p>
<p>"Error": any error / exception not related to the certificate chain validation (algorithm) itself</p>
<p>"Unknown": validation result is unknown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MbedTLS:
    &#34;&#34;&#34;
    A class for certificate chain validation client utilizing command-line MbedTLS.

    Special error messages:

    &#34;Error&#34;: any error / exception not related to the certificate chain validation (algorithm) itself

    &#34;Unknown&#34;: validation result is unknown
    &#34;&#34;&#34;

    TRUST_STORE_FILE = &#34;/etc/pki/tls/cert.pem&#34;

    @staticmethod
    def verify(chain, reference_time=None, crl=None, **kwargs):
        &#34;&#34;&#34;
        Validates a certificate chain.

        `chain` is a list of paths to certificates forming a chain.
        `reference_time` is a reference time of validation in seconds since the epoch.
        `crl` is a path to CRL.
        `kwargs` are other, unexpected arguments.

        The returned result is a list of a set of error messages returned by command-line MbedTLS.
        &#34;&#34;&#34;

        chain = list(chain)

        try:
            with tempfile.NamedTemporaryFile() as chain_file:
                for i in range(len(chain)):
                    with open(chain[i]) as input_file:
                        chain[i] = input_file.read()

                    chain_file.write(chain[i].encode())

                chain_file.flush()

                command = []

                if reference_time:
                    command += MbedTLS.__get_faketime_command(reference_time)

                command += [&#34;mbedtls_cert_app&#34;, &#34;mode=file&#34;, &#34;filename={0}&#34;.format(chain_file.name), &#34;ca_file={0}&#34;.format(MbedTLS.TRUST_STORE_FILE)]

                if crl:
                    command += [&#34;crl_file={0}&#34;.format(crl)]

                command_output_lines = [line.strip() for line in subprocess.check_output([&#34; &#34;.join(command)], shell=True).decode(errors=&#34;ignore&#34;).strip().split(&#34;\n&#34;)]

                result = [&#34;Unknown&#34;]

                if command_output_lines[-1] == &#34;ok&#34;:
                    result = [&#34;Verified&#34;]
                elif command_output_lines[-1][0] == &#34;!&#34;:
                    messages = []

                    for i, line in enumerate(command_output_lines):
                        if line == &#34;failed&#34;:
                            for message_line in command_output_lines[i + 1:]:
                                if message_line[0] == &#34;!&#34;:
                                    messages.append(&#34;&#34;.join([word.capitalize() for word in message_line[1:].split()]))

                            break

                    if len(messages) &gt; 0:
                        result = sorted(set(messages))
        except Exception:
            result = [&#34;Error&#34;]

        return result

    @staticmethod
    def is_setup_correctly():
        &#34;&#34;&#34;
        Verifies that the validation client is set up correctly. (MbedTLS is installed, reference time works,
        and trust store exists)
        &#34;&#34;&#34;

        is_setup_correctly = True

        try:
            subprocess.check_output(&#34; &#34;.join([&#34;type&#34;, &#34;mbedtls_cert_app&#34;]), stderr=subprocess.DEVNULL, shell=True)
        except Exception:
            is_setup_correctly = False

        if is_setup_correctly:
            try:
                command_output = subprocess.check_output(&#34; &#34;.join(MbedTLS.__get_faketime_command(0) + [&#34;date&#34;, &#34;-u&#34;]), stderr=subprocess.DEVNULL, shell=True)

                if command_output.decode().strip() != &#34;Thu  1 Jan 01:00:00 CET 1970&#34;:
                    is_setup_correctly = False
            except Exception:
                is_setup_correctly = False

        if is_setup_correctly:
            if not os.path.isfile(MbedTLS.TRUST_STORE_FILE):
                is_setup_correctly = False

        return is_setup_correctly

    @staticmethod
    def __get_faketime_command(reference_time):
        return [&#34;LD_PRELOAD={0}&#34;.format(os.path.join(os.path.dirname(os.path.realpath(__file__)), &#34;libfaketime.so.1&#34;)),
                &#34;FAKETIME=\&#34;{0}\&#34;&#34;.format(datetime.datetime.fromtimestamp(reference_time).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;))]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.TRUST_STORE_FILE"><code class="name">var <span class="ident">TRUST_STORE_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.is_setup_correctly"><code class="name flex">
<span>def <span class="ident">is_setup_correctly</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies that the validation client is set up correctly. (MbedTLS is installed, reference time works,
and trust store exists)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_setup_correctly():
    &#34;&#34;&#34;
    Verifies that the validation client is set up correctly. (MbedTLS is installed, reference time works,
    and trust store exists)
    &#34;&#34;&#34;

    is_setup_correctly = True

    try:
        subprocess.check_output(&#34; &#34;.join([&#34;type&#34;, &#34;mbedtls_cert_app&#34;]), stderr=subprocess.DEVNULL, shell=True)
    except Exception:
        is_setup_correctly = False

    if is_setup_correctly:
        try:
            command_output = subprocess.check_output(&#34; &#34;.join(MbedTLS.__get_faketime_command(0) + [&#34;date&#34;, &#34;-u&#34;]), stderr=subprocess.DEVNULL, shell=True)

            if command_output.decode().strip() != &#34;Thu  1 Jan 01:00:00 CET 1970&#34;:
                is_setup_correctly = False
        except Exception:
            is_setup_correctly = False

    if is_setup_correctly:
        if not os.path.isfile(MbedTLS.TRUST_STORE_FILE):
            is_setup_correctly = False

    return is_setup_correctly</code></pre>
</details>
</dd>
<dt id="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>chain, reference_time=None, crl=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Validates a certificate chain.</p>
<p><code>chain</code> is a list of paths to certificates forming a chain.
<code>reference_time</code> is a reference time of validation in seconds since the epoch.
<code>crl</code> is a path to CRL.
<code>kwargs</code> are other, unexpected arguments.</p>
<p>The returned result is a list of a set of error messages returned by command-line MbedTLS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def verify(chain, reference_time=None, crl=None, **kwargs):
    &#34;&#34;&#34;
    Validates a certificate chain.

    `chain` is a list of paths to certificates forming a chain.
    `reference_time` is a reference time of validation in seconds since the epoch.
    `crl` is a path to CRL.
    `kwargs` are other, unexpected arguments.

    The returned result is a list of a set of error messages returned by command-line MbedTLS.
    &#34;&#34;&#34;

    chain = list(chain)

    try:
        with tempfile.NamedTemporaryFile() as chain_file:
            for i in range(len(chain)):
                with open(chain[i]) as input_file:
                    chain[i] = input_file.read()

                chain_file.write(chain[i].encode())

            chain_file.flush()

            command = []

            if reference_time:
                command += MbedTLS.__get_faketime_command(reference_time)

            command += [&#34;mbedtls_cert_app&#34;, &#34;mode=file&#34;, &#34;filename={0}&#34;.format(chain_file.name), &#34;ca_file={0}&#34;.format(MbedTLS.TRUST_STORE_FILE)]

            if crl:
                command += [&#34;crl_file={0}&#34;.format(crl)]

            command_output_lines = [line.strip() for line in subprocess.check_output([&#34; &#34;.join(command)], shell=True).decode(errors=&#34;ignore&#34;).strip().split(&#34;\n&#34;)]

            result = [&#34;Unknown&#34;]

            if command_output_lines[-1] == &#34;ok&#34;:
                result = [&#34;Verified&#34;]
            elif command_output_lines[-1][0] == &#34;!&#34;:
                messages = []

                for i, line in enumerate(command_output_lines):
                    if line == &#34;failed&#34;:
                        for message_line in command_output_lines[i + 1:]:
                            if message_line[0] == &#34;!&#34;:
                                messages.append(&#34;&#34;.join([word.capitalize() for word in message_line[1:].split()]))

                        break

                if len(messages) &gt; 0:
                    result = sorted(set(messages))
    except Exception:
        result = [&#34;Error&#34;]

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cevast.analysis.modules.validation_clients" href="index.html">cevast.analysis.modules.validation_clients</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS" href="#cevast.analysis.modules.validation_clients.mbedtls.MbedTLS">MbedTLS</a></code></h4>
<ul class="">
<li><code><a title="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.TRUST_STORE_FILE" href="#cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.TRUST_STORE_FILE">TRUST_STORE_FILE</a></code></li>
<li><code><a title="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.is_setup_correctly" href="#cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.is_setup_correctly">is_setup_correctly</a></code></li>
<li><code><a title="cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.verify" href="#cevast.analysis.modules.validation_clients.mbedtls.MbedTLS.verify">verify</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>